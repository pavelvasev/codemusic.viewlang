сделать чтобы compute не сразу вызывался а позже? когда нескольок input-oв?

Qt.later( ... ) и это значит что тик пересчета и рассылки сигналов поставлен в очередь
будет, а не стразу рассчитается. это нам для compute полезно когда инпуты быстро меняются

как делать - идея, пусть возвращает ключ { daslater: true } и ставит settimeout..
ну а кути ловит daslater и ниче не делает... но например запоминает себе что надо вызывать..
может даже оно settimeout то и ставит и таблицу учета таймаутов ведет..

!!!!!

Qt.later( function() { return func_alfa( input_1, input_2 ) }

Qt.later:
1. Если стадия - инициализация движка, то он вычисляет свой аргумент и все. Там зависимости посчитаются.
2. Если стадия - работа, 
   * то он ставит таймаут, запоминает его в контексте (объект, имя свойства расчетного...)
   * а если был там таймаут, то удаляет его
   * возвращает особый флаг, который говорит что update рассылать не надо и значение свойства заменять пока тоже.
   
/// кстати идея - все зависимости передавать в Qt.later наравне с функцией, тогда это стандартные
отслеживания на уровне qml свойств....


***
там какая-то непонятка, вроде есть __executionObject но он не очень доступен вроде
но можено!
в update всю логику утоащить.

т..е вернули { later: true } и это значит - val не записывать, а запустить таймер.
а если уже было later флаг, то очистить таймер. 
а таймер запустить - но надо как-то повторно eval вызывать и сказать что возражения уже не принимаются
в текущем кадре.

+ както это сделать чтобы вложенное работало..
т.е. если later вызвал в конце концов eval, а там тыркнулось вложенное.. хотя ладно, оно может срабатывать..

----
теперь вопрос, а могу  ли я это реализовать не влазия в qt а сделав на уровне компонента?
ну вот была идея - создать объект DeferredCalculcation и там все оные input-ы фигурировать..
а точнее отслеживать на уровне парента.. ну блин или туда прокинуть, input_1 : parent.input_1
и сказать, что запускаю таймер свой..

наверное это будет работать.. только надо научиться ловить это когда хотели.. типа не только для output но и для position..

Ладно, подумаю. Пока поесть и Митричу ответить.

*****
кстати, а может надо испускать сигналы не сразу..
делаем типа
SignalDeferred {
  signals: ["input1Changed", "input2Changed"]
}  
и типа когда их издают, не издавать, а запихивать в ареал общий.. так а шо дальше то?
потом когда время придет - надо все-равно их ловить будет..

----
пока интуитивно самое простое это типа
Qt.later( obj, name, [var1, var2, var3, ...], function() { })
ну и типа трулулю вызывают а мы такие ниче ни делаем.
а потом делаем и пишем в obj.name?

  
  *******
сделано

папка elements/later и файл public/DeferredCalc.qml
компонент который отслеживает изменение своих параметров и пишет в родительскую пропертю когда выходит таймаут