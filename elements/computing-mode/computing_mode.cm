`` режим, активирующий автоматическое создание qml-объектов для вычисления
`` сейчас идет отметка, что это работает только для root-узлов

###### computing_mode.rb prepend=true @computing_mode_rules
ctx.machine.add_cond [nil,:root], :auto_qml_obj, :scope_level => :all

###### computing_mode.rb @computing_mode_call_input
ctx.r = ctx.input

`` очень тонкий момент. надо активировать computing-mode для вычисления аттрибутов..
`` иначе там получается непонятная история.. хотя..
###### attr.rb prepend=true @activate_comp_mode_for_attrs
ctx.machine.compute_in_context( {:tag => :computing_mode_rules} )
``ctx.machine.add_cond [:attr], :auto_qml_obj
``<computing_mode/>
``@machine.add_cond [:attr], :auto_qml_obj # допом - для аттрибутов

###### auto_qml_obj.rb!
`` дано: ctx.r - текущий результат, нам надо - строка с функцией
`` задача - сгенерировать qml-узел из этого добра

# доп защита - чтобы не обрабатывать раньше времени
#if ctx[:code_track].length != 2
#  ctx.machine.log ">>> code track not 2, skipping"
#  return
#end

r = ctx.r
if !r.is_a?(String) || r !~ /function/
  ctx.r = r
  return
end
ctx.machine.log ">>> i gonna generate computing node now. ctx.r=#{ctx.r.inspect}"

inputs = ctx.input
input_records = []
inputs.each_with_index do |input,index|
  t = { :tag => :property, :name => "input_#{index}", :value => input }
  input_records.push t
end

func_name = "func_#{ctx.obj[:name]}"
output_record = [ 
  { :tag => :property, :name => "output", 
    :value => ("#{func_name}( " + input_records.map.with_index{ |r,index| "input_#{index}" }.join(",") + " )" ) 
  }
]
#body = input_records.concat( output_record )
body = output_record.concat( input_records ) # надо аутпут сначала вывести, а то потом крышеснос читать qml

func_code = r.sub(/^\s*function/, "function #{func_name}") # было gsub а это неверно - надо только первое вхождение менять
@das_moved_funcs ||= {}
@das_moved_funcs[ func_name ] = func_code

@gcn_autocounter||=0
obj={
  :tag => :object,
  :type => "Item",
  :id => "#{ctx.obj[:name]}_#{@gcn_autocounter=@gcn_autocounter+1}",
  :items => body,
  :comment => "generated by auto_qml_obj",
  :xtract_from_property => true
}
ctx.machine.log ">>> auto_qml_obj: generated object #{obj.inspect}"
ctx.r = obj

###### scene.rb @add_funcs priority=-5
isfirst=true
(@das_moved_funcs || []).each do |k,v|
  if isfirst
    deploy_qml_item( ctx.r, "\n///////////////// functions!\n" )
    isfirst = false
  end

  deploy_qml_item( ctx.r, { :tag => :expression, :value => v } )
end
